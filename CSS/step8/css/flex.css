.flexContainer{
    margin: 10px; padding: 15px; border-radius: 23px; background-color: #a4a4a4;
    display: flex;
}
.flexItem{
    margin: 10px; padding: 20px; color: white; text-align: center; border-radius: 27px;
    background-color: black;
}
.flexContainer.direction{
    flex-direction: row;
    /* 
        ? row : left to right
        ? row-reverse : right to left
        ? column : top to bottom
        ? column-reverse : bottom to top
    */
}
.flexContainer.wrap{
    flex-wrap: wrap-reverse; flex-direction: row-reverse;
    /* 
        ? nowrap(개행불허. 1행 모두 배치. default. flexItem Width 자동축소)
        ? wrap(width 초과시 개행)
        ? wrap-reverse(개행하되 역배치)
    */
}
.flexContainer.wrap .flexItem,
.flexContainer.flow .flexItem{
    width: 500px;
}

.flexContainer.flow{
    flex-flow: row-reverse wrap-reverse;
    /* ? flex-flow : <directionValue> | <wrapValue> */
}
.flexContainer.justifyContent{
    justify-content: space-evenly; padding: 0;    
}
.flexContainer.justifyContent .flexItem,
.flexContainer.alignContent .flexItem{
    margin: 0;
}
.flexContainer.alignContent{
    align-content: space-evenly; justify-content: flex-end; height: 400px; flex-wrap: wrap;
    padding: 0; 
}
.flexContainer.alignContent .flexItem{
    width: 500px;
}
.flexContainer.justifyItems{
    background-color: yellow; width: 300px; display: grid;
    flex-direction: column;
    justify-items: center;
}
.flexContainer.justifyItems:hover{
    justify-items: flex-start;
}

.flexContainer.alignItems{
    background-color: orange; align-items: center;
}
.flexContainer.alignItems:hover{
    align-items: flex-end;
}
.flexContainer.alignItems .flexItem:first-of-type{
    line-height: 50px;
}
.flexContainer.alignItems .flexItem:nth-of-type(2){
    line-height: 100px;
}
/* ! -items: space 3형제없음. */
.flexContainer.justifySelf{
    width: 220px; display: grid;
}
.flexContainer.justifySelf .flexItem:first-of-type{
    justify-self: stretch;
}
.flexContainer.justifySelf:hover .flexItem:first-of-type{
    justify-self: center;
}
.flexContainer.alignSelf{
    justify-content: space-between;
}
.flexContainer.alignSelf .flexItem:first-of-type{
    align-self: flex-end;
}
.flexContainer.alignSelf:hover .flexItem:first-of-type{
    align-self: flex-start;
}
.flexContainer.alignSelf .flexItem:nth-of-type(2){
    line-height: 100px;
}


.flexContainer.orderItem .flexItem.order1{
    order: 1;
}
.flexContainer.orderItem .flexItem.order2{
    order: 0;
}
.flexContainer.orderItem .flexItem.order3{
    order: -2;
}
.flexContainer.flexShortHand{
    width: 50%; margin: 0; padding: 0; background-color: lightgreen;
    /* *case.2 Test max-width: 300px; */
}
.flexContainer.flexShortHand .flexItem{
    margin: 0; padding: 0; word-break: break-all;
}
.flexContainer.flexShortHand .flexItem:first-of-type{
    /* *case.1 grow flex-grow: 2; flex-basis: 0; */
    /* *case.2 flex-shrink: 2; flex-basis: 150px; */
    flex-basis: 150px;
}
.flexContainer.flexShortHand .flexItem:first-of-type~*{
    /* *case.1 grow flex-grow: 1; flex-basis: 0; */
    /* *case.2 flex-shrink: 1; flex-basis: 150px; */
    flex-basis: 150px;
}
/*
    ? flex-grow(팽창(확장)비):
    ! item의 증가비율을 정한다. default: 0. 즉, 빈 공간을 알아서 확장하여 채우지 않는다.
    ! 음수 비허용. 양수 입력 시 '총 증가 내부팽창지수(grow합산)의 너비중 입력된 비율만큼의 너비를 가진다.
    ! 단, max-width가 설정되면 해당 수치를 넘지 않는다.
    * example. item이 3개이고 item들에게 grow가 1이 부여된다면 각각 1/3(33.33%)의 너비를 갖게 된다.

    ?ex.1 > 만약 전체 너비 (300px)의 item 3개에 개별적으로 grow가 부여되었다면?
    todo. flexItem:first-child{flex-grow:2;} -> 0(basis) + (300/4)*2 = 150.
    todo. flexItem:first-child~*{flex-grow:1;} -> 0(basis) + (300/4)*1 = 75.
    ? why 3(x) 4? = first 2 +  ~* 1 + 1.
*/
/*
    ? flex-shrink(수축비):
    ! 기준되는 부모(절대)가 줄어들 때 item의 수축비를 정한다. default: 1.
    ! 음수 비허용. 양수 입력 시 '총 수축 내부수축지수(shrink합산)의 너비 중 입력된 비율 만큼 수축될 수 있다.
    ! 단, min-width가 설정되면 해당 수치를 넘지 않는다. (basis -> max로 변환 가동)
    * example. item이 3개이고 item들에게 shrink가 1이 부여된다면 각각 1/3의 수축비를 갖게된다.
    ?ex. 2 > 만약 수축중인 부모 너비가 300px인 item 4개(각너비 150px)에  shrink를 부여하면?
    todo. 초과되는 수치인 150 에 대한. shrink총합인 4를 나눈 37.5가 곧 shrink: 1이된다.
    todo. flexItem:first-child{flex-shrink: 2;} -> 150(대상너비) - (150/4)*2 = 75;
    todo. flexItem:first-child~*{flex-shrink: 1;} -> 150(대상너비) - (150/4)*1 = 112.5;

*/
/*
    basis:
    !item의 너비를 정한다. 기본값은 auto 이며 다양한 단위 percentages(%) || ems || rems || pixels 를 사용 할 수있다.
    auto : 안의 컨텐츠의 길이만큼 너비가 늘어난다.
*/
/*

    * 생략되는 형식
    flex: none;
    flex-grow:0; flex-shrink:0; flex-basis:auto; 상태가 된다.

    flex: <flex-grow>
    flex-shrink:1; flex-basis:0; 상태가 된다.

    flex: <flex-basis>
    flex-grow:1; flex-shrink:1; 상태가 된다.

    flex: <flex-grow> <flex-shrink>
    flex-basis:0; 상태가 된다.

    flex: <flex-grow> <flex-basis>
    flex-shrink:1; 상태가 된다.

    flex: <flex-grow> <flex-shrink> <flex-basis>
    생략한 속성 없음.
    
    todo 자주 사용되는 형식
    1. flex: 0 1 auto; : 확장비는 존재 하지 않고 (남은공간을 채우지 않는다.), 수축만 일어나며 컨텐츠의 너비만큼 너비가 설정된다.
    2. flex: none; : 확장비, 수축비 모두 존재하지 않는다.(남은공간을 채우지도 수축도 일어나지 않는다.)  컨텐츠의 너비만큼 너비가 설정된다.
    3. flex: auto; : 1 1 auto 와 같다. 확장비, 수축비 모두 컨텐츠 갯수만큼 비율로 분배되어 갖게 되고, 컨텐츠의 너비만큼 너비가 설정된다.
    !만약 그 너비가 컨텐츠 보다 작을땐 item이 container의 너비를 넘는다. (스크롤바 발생) word-break : break-all 로 제어.


*/